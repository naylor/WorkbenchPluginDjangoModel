# MySQL Workbench Plugin
# <description>
# Written in MySQL Workbench 8.0.36

from wb import *
import grt
import mforms
import re

ModuleInfo = DefineModule("djangoModel", author="Bachiega, Naylor G.", version="1.0.0", description="Generate Export to Django Model")

# This plugin takes no arguments
@ModuleInfo.plugin("export.djangoModel", caption="Generate Export to Django Model", description="description", input=[wbinputs.currentDiagram()], pluginMenu="Utilities")
@ModuleInfo.export(grt.INT, grt.classes.db_Catalog)

def djangoModel(diagram):
    newline = "\n"
    separator = ":"
    tab = "    "
    yml = ""
    obj_count = 0
    tables = []
    
    # Itera sobre os esquemas na categoria
    for figure in diagram.figures:
    
        table = TableSkeleton()
        # Itera sobre as colunas na tabela
        for column in figure.table.columns:
            print("djangoModel: for column")
            obj_count += 1

            current_column = ColumnSkeleton()
            current_column.name = column.name
            current_column.orig_name = column.name
            current_column.type = simple_type_to_django_field_type(column.simpleType)
            current_column.obj_count = obj_count

            # Tamanho
            current_column.length = 0 if column.length == -1 else column.length

            # Precisão
            current_column.precision = 0 if column.precision == -1 else column.precision

            # Escala
            current_column.scale = 0 if column.scale == -1 else column.scale

            # Obrigatório (not null)
            current_column.required = column.isNotNull == 1

            # Auto-incremento
            current_column.auto_increment = column.autoIncrement == 1

            # Valor padrão
            if column.defaultValue:
                if "'" in column.defaultValue:
                    current_column.default = column.defaultValue[1:-1]
                else:
                    current_column.default = column.defaultValue

            # Chave primária
            if figure.table.indices:
                for index in figure.table.indices:
                    if index.indexType == "PRIMARY":
                        for index_column in index.columns:
                            if index_column.referencedColumn and index_column.referencedColumn.name == column.name:
                                current_column.primaryKey = True

            # Chave estrangeira
            if len(figure.table.foreignKeys) > 0:
                for foreignKey in figure.table.foreignKeys:
                    foreignKeyColumn = foreignKey.columns[0]
                    foreignKeyReferencedColumn = foreignKey.referencedColumns[0]

                    if foreignKeyColumn.name == column.name:
                        if foreignKey.referencedTable is not None:
                            current_column.foreignTable = foreignKey.referencedTable.name
                            current_column.foreignReference = foreignKeyReferencedColumn.name
                            if current_column.name.endswith("_id"):
                                current_column.name = current_column.name[:-3]

                        if foreignKey.deleteRule == "SET NULL":
                            current_column.onDelete = "SET_NULL"
                        elif foreignKey.deleteRule == "CASCADE":
                            current_column.onDelete = "CASCADE"
                        elif foreignKey.deleteRule == "NO ACTION" or foreignKey.deleteRule == "RESTRICT":
                            current_column.onDelete = "RESTRICT"

            # Índices
            if figure.table.indices:
                for index in figure.table.indices:
                    if index.indexType == "INDEX" and index.name == column.name:
                        current_column.index = True
                    if index.indexType == "UNIQUE" and index.name == column.name:
                        current_column.unique = True

            current_column.row_table_name = figure.table.name
            print("row_table_name: " + current_column.row_table_name)

            # Many to Many
            if "_has_" in figure.table.name:
                current_column['manyToMany'] = convert_table_to_class_name(figure.table.name)
                current_column['foreignReference'] = None
                table_name = figure.table.name.split("_has_")[0]
                table.name = convert_table_to_class_name(figure.table_name)
                table.columns.append(current_column)
            else:
                table.name = convert_table_to_class_name(figure.table.name)
                table.columns.append(current_column)
                # yml += tab + current_column['name'] + " = models." + current_column.get_field_str() + newline

            print(current_column)    
        
        tables.append(table)


    # Monta o Django Model
    yml = "Model generated by the Generate Export to Django Model Plugin" + newline
    yml += "Created by Naylor Garcia Bachiega" + newline
    yml += "https://github.com/naylor" + newline + newline
    yml += "from django.db import models" + newline + newline
    #tables = sort_table_array(tables)
    for table in tables:
        print(table)
        print(table.name)
        yml += convert_to_django_model(table)

    mforms.Utilities.set_clipboard_text(yml)
    mforms.App.get().set_status_text("Documentation generated into the clipboard. Paste it to your editor.")

    print("Documentation is copied to the clipboard.")
    return 0


class TableSkeleton:
    def __init__(self):
        self.name = None, 
        self.columns = []

class ColumnSkeleton:
    def __init__(self):
        self.obj_count = 0
        self.name = None
        self.orig_name = None
        self.required = False
        self.primaryKey = False
        self.autoIncrement = False
        self.type = None
        self.length = 0
        self.default = None
        self.sequence = None
        self.index = False
        self.foreignTable = None
        self.foreignReference = None
        self.onDelete = None
        self.isCulture = False
        self.precision = 0
        self.scale = 0
        self.unique = False
        self.manyToMany = None
        self.row_table_name = None

    # Adicione outros métodos aqui, se necessário


def convert_to_django_model(table):
    newline = "\n"
    tab = "    "
    yml = ""

    # Convert table name to Django model class name
    yml += f"class {convert_table_to_class_name(table.name)}(models.Model):" + newline

    for column in table.columns:
        field_str = get_field_str(column)
        if field_str:
            yml += tab + field_str + newline
    
    yml = yml + newline
    return yml


def get_field_str(column):
    sep = ", "
    yml = f"{column.name} = models."

    if column.manyToMany is not None:
        print("GET 0")
        print(column.row_table_name)
        table_name_first = column.row_table_name.split("_has_")[0]
        table_name_last = column.row_table_name.split("_has_")[1]
        print("GET 1")

        if convert_table_to_class_name(column.name) != convert_table_to_class_name(table_name_first):
            yml = f"{column.name}s = models.ManyToManyField({convert_table_to_class_name(table_name_last)}"
            yml += f"{sep}db_table='{column.manyToMany}'{sep}"
        else:
            return ""

    elif column.foreignTable is not None:
        yml += f"ForeignKey('{convert_table_to_class_name(column.foreignTable)}'{sep}"

    if column.foreignReference is not None:
        yml += f"to_field='{column.foreignReference}'{sep}"
        yml += f"related_name='{column.orig_name}_{column.obj_count}'{sep}"

    if column.onDelete is not None:
        yml += f"on_delete=models.{column.onDelete}{sep}"

    if column.foreignTable is not None:
        yml = yml.rstrip(sep)
        yml += ")"
        return yml

    print("OK")

    if column.autoIncrement:
        print("OK1")
        column.type = "AutoField"

    yml += f"{column.type}("

    if column.length != 0:
        yml += f"max_length={column.length}{sep}"

    if not column.required:
        yml += f"blank=True{sep}"

    if column.precision != 0:
        yml += f"max_digits={column.precision}{sep}"

    if column.scale != 0:
        yml += f"decimal_places={column.scale}{sep}"

    if column.primaryKey:
        yml += f"primary_key=True{sep}"

    if column.default is not None and column.default != "NULL":
        yml += f"default='{column.default}'{sep}"

    if column.index:
        yml += f"db_index=True{sep}"

    if column.unique:
        yml += f"unique=True{sep}"

    if column.type == "DateTimeField" and column.name == "created_at":
        yml += f"auto_now_add=True{sep}"

    if column.type == "DateTimeField" and column.name == "updated_at":
        yml += f"auto_now=True{sep}"

    if not yml.endswith('('):
        yml = yml.rstrip(sep)

    yml += ")"

    return yml

def sort_table_array(tables):
    sorted_tables = []

    # Primeiro, adiciona as tabelas que não possuem campos ManyToMany
    for table in tables:
        mToN = False
        for column in table.columns:
            if hasattr(column, "manyToMany"):
                mToN = True

        if mToN == False:
            sorted_tables.append(table)

    # Em seguida, adiciona as tabelas que possuem campos ManyToMany
    for table in tables:
        mToN = False
        for column in table.columns:
            if hasattr(column, "manyToMany"):
                mToN = True

        if mToN == True:
            sorted_tables.append(table)

    return sorted_tables


def convert_table_to_class_name(s):
    s = s.capitalize()  # Converte o primeiro caractere para maiúsculo
    s = ''.join(word.capitalize() if word else '_' for word in s.split('_'))  # Converte caracteres após '_' para maiúsculo
    return s.replace('_', '')  # Remove os '_'

def trim(s):
    return s.strip()  # Remove espaços em branco do início e do final

def string_starts(s, start):
    return s.startswith(start)  # Verifica se a string começa com o prefixo especificado

def string_ends(s, end):
    return s.endswith(end)  # Verifica se a string termina com o sufixo especificado

def strpos(haystack, needle, offset=0):
    pos = haystack.find(needle, offset)  # Encontra a posição da primeira ocorrência da substring
    return pos if pos != -1 else None

def simple_type_to_django_field_type(simple_type):
    if simple_type is not None:
        django_type = "NOT_MATCHED"
        if simple_type.name == "INT":
            django_type = "IntegerField"
        elif simple_type.name == "BIGINT":
            django_type = "BigIntegerField"
        elif simple_type.name == "DECIMAL":
            django_type = "DecimalField"
        elif simple_type.name in ["DATETIME", "TIMESTAMP"]:
            django_type = "DateTimeField"
        elif simple_type.name == "DATE":
            django_type = "DateField"
        elif simple_type.name == "TIME":
            django_type = "TimeField"
        elif simple_type.name in ["BOOL", "TINYINT"]:
            django_type = "BooleanField"
        elif simple_type.name in ["FLOAT", "DOUBLE"]:
            django_type = "FloatField"
        elif simple_type.name in ["TINYTEXT", "VARCHAR", "CHAR"]:
            django_type = "CharField"
        elif simple_type.name in ["TEXT", "MEDIUMTEXT", "LONGTEXT"]:
            django_type = "TextField"

        return django_type
    else:
        return "UNKNOWN"
